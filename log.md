# 

本日志记录开发过程中的思考

## 逐日开发进度

### 2025-01-15

#### 程序目的

模拟实现扫雷

#### 结构设计

1. 界面设计
   1. 常规界面
      1. 剩余雷数计数
      2. 单局计时
      3. 开始按钮
      4. 扫雷区域
   2. 扫雷区域：鼠标点击-界面反馈
      1. 
2. 算法
   1. 雷的生成、格子的检测算法、点击排雷算法

### 2025-01-16

#### 难度类别设置

按钮，自带难度属性，通过内置方法修改雷区的属性

1. 基础
2. 中级
3. 专家
4. 满屏
5. 自定义

### 2025-01-17

#### 雷区单格状态

1. 覆盖层
   1. 空白未扫格（覆盖、虚化）
   2. 标记格
   3. 已扫格（已变为真实层）
2. 真实层
   1. 雷:'*'
   2. 数字:'1'、'2'、'3'、'4'、'5'、'6'、'7'、'8'
   3. 空:' '

#### 雷区真实层生成算法

1. 使用随机函数生成雷坐标凑够雷数
2. 遍历标记生成数字和空白

#### 雷区覆盖层交互

##### 逻辑

1. 左键点击空白未扫格
   1. 真实层为空白，显示连片的空白和边缘的数字
   2. 真实层为数字，显示本格数字
   3. 真实层为雷，游戏失败，本格雷引爆变红，显示所有雷
2. 左键点击标记格：无反应
3. 左键点击已扫格
   1. 空白、雷：无反应
   2. 数字
      1. 周围八格标记数量与雷数量一致
         1. 雷与标记位置相符合，将相连的真实层为空白的格子、周围八格真实层为数字的覆盖层去除
         2. 雷与标记位置不符合，引爆未标记的雷，触发游戏结束
      2. 周围八格标记数量少于雷数，覆盖层空白未扫格虚化后还原
      3. 周围八格标记数量多于雷数，无反应
4. 右键点击空白未扫格：标记
5. 右键点击标记格：取消标记
6. 如果所有真实层为空白和数字的区域全部被去除了覆盖层，游戏胜利，显示所有雷

### 2025-01-18

#### 开发计划

1. 计时器
2. 确保第一次点击不是雷，即初次点击后生成雷的分布
3. 真实层数字标号颜色还原
4. 游戏胜利
5. 点击数字，相应反应


#### 进度

1. 计数器完成
2. 游戏胜利完成
3. 点击数字，相应反应实现

#### 剩余计划

1. 确保第一次点击不是雷，即初次点击后生成雷的分布
2. 真实层数字标号颜色还原

### 2025-01-19

#### 开发计划

1. 还原数字颜色
2. 修复切换难度胜利图标不变换的bug
3. 初次点击后生成雷的分布，确保初次点击不是雷
4. 自定义模式
5. 雷的样式调整
6. 判定胜利的逻辑优化
7. 剩余标记数显示的优化

#### 进度

1. 修复切换难度胜利图标不变换的bug，整合game_state，在restart类handle_event里加入对game_state == 'new_game'的判别
2. 还原数字颜色，每格数字对应一个预设颜色
3. 调整雷（*）的样式，使得雷显示在格子的中央，调大雷的显示大小
4. 修改雷分布的生成逻辑，初次点击后生成雷的分布，确保初次点击不是雷
5. 优化判定胜利的逻辑，详见逐项开发进度中的胜利判定
6. 优化剩余标记数显示

### 2025-01-20

#### 开发计划

1. 自动扫雷
2. 修改判定游戏失败逻辑

#### 进度

1. 实现半自动扫雷，仍有bug（1），采用初级逻辑
2. 修改判定游戏失败，bug（1）

#### 明日计划

1. 用时记录（分纯手动和半自动），设计文件存储方式
2. 探索中级自动扫雷思路

### 2025-01-23

**创设开发计划日志模块**

### 2025-01-24

#### 进度

1. 图标图片替换、优化

### 2025-01-25

#### 进度

1. 实现restart图标按下反应，即立体化
2. 书写自动扫雷中级规则
3. 验证自定义模式调节框（暂未加入输入）

### 2025-01-26

#### 进度

1. 装载自定义框(位置、初始化、样式)
2. 测试总分式架构设计
3. 修复放置类的时候出现的问题，防止溢出（采用全防止类型，未作雷允许在点击位置3*3范围内的特判）
4. 自定义框功能化
5. 写入框调节箭头悬浮效果
6. 自定义框隐藏
7. 初步完成自定义模式功能开发

### 2025-01-27

#### 计划

1. 分离半自动扫雷和手动扫雷，做成可自由开关的功能

#### 进度

1. 保存自定义模式版本为v1.2.0
2. 初步测试键盘控制开关成立
3. 测试发现在init里不能放其他实例的变量
4. MineArea类auto_sweep方法中使用卫语句简化逻辑
5. 采用分离同步简单地实现开关，在mine_sweeper和mine_area里各放一个self.auto_sweep_state量，同时更新。MineSweeper中用于更新显示量，MineArea中用于更新状态量
6. 实现半自动扫雷的开关功能

### 2025-01-28

#### 计划

1. 寻找新的开发点
2. 完善注释
3. 完善程序体系架构，使其健壮、清晰

#### 进度

1. 删除之前版本遗留的已经注释的代码块，若有需要使用可以回溯至已保存的版本
2. 完善注释

### 2025-01-30

#### 计划

1. 继续完善注释，整理架构
2. 学习AI提供的架构思路

#### 进度

1. 创建v1.2.1版本
2. 测试分文件config、asset设计

### 2025-02-02

#### 计划

1. 继续修改代码，调整结构

#### 进度

1. 修改config.py，存储更多硬编码至config文件中

### 2025-02-03

#### 计划

1. 继续调整程序结构，将所有的硬编码统一规整到config.py文件当中
2. 开始着手设计组合逻辑规则下的自动扫雷及其相应优化措施

#### 进度

1. 修改字体参数结构，修改config.py和assets.py
2. 保存版本1.3.0

### 2025-02-04

#### 计划

1. 开发自动扫雷

#### 进度

1. 尝试开发组合逻辑，但是尚未成功
2. 发现覆盖层虚化状态会出现BUG，尝试分离虚化状态做单独控制量，同时排查覆盖层状态判断，做到唯一性控制
3. 查明原因，自动扫雷组合逻辑统计空白未扫时如果产生虚化会干扰统计
4. main.py中MineArea类新增ghost_board存储虚化状态，修改相应控制和渲染
5. 修改完毕，实测无bug出现，目前已完成组合逻辑4
6. 实现组合逻辑
7. 优化运行逻辑，减少不必要的规则运行

### 2025-02-05

#### 计划

1. 继续开发自动扫雷功能

#### 进度

1. 完成优化自动扫雷部分

### 2025-02-06

#### 计划

1. 分离全手动点击扫雷和半自动识别扫雷（点击数字判断是否已满足条件则自动点出格子）

#### 进度

1. 成功分离出辅助手动扫雷功能
2. log文件添加游戏功能栏目，简单介绍游戏目前拥有的功能
3. 修改逐项开发为开发项，进一步明确其功能
4. 修改逐项开发进度交互功能一栏，添加层次编号型

### 2025-02-07

#### 计划

1. 鼠标点击次数

#### 进度

1. 实现鼠标点击次数统计

### 2025-02-08

#### 计划

1. 增加用时记录功能

#### 进度

1. 创建文件records.py，用于处理用时记录
2. records.py中设置处理并存储用时记录的方法，并且有根据两个功能开关的设置
3. 初步实现用时记录功能，尚未完善模式优先级的设置（即一旦开启辅助、自动即视为辅助、自动）

### 2025-02-09

#### 计划

1. 优化用时记录，添加使用自动、辅助高优先级判定

#### 进度

1. 完成高优先级判定

### 2025-02-10

#### 计划

1. 添加显示创造记录者的功能

### 2025-02-16

#### 计划

1. 使用MVC架构重构代码
2. 发现从现有版本更改难度过大，重新使用MVC架构写起试试看

#### 进度

1. 优化records，同样的时间记录将不再被记录
2. 保存版本v1.3.3A
3. 创建新版本v0.1.0Beta，用于MVC架构测试性开发

### 2025-02-18

#### 计划

1. 继续挑战MVC架构构建代码

#### 进度

1. 修改main注释1处
2. 实践新的注释思想：类方法注释用三单引号于方法名下一行，单行注释用井号位于行末，多行注释用井号位于段前。
3. MVC，VIEW界面初步设计

## 开发项

### 交互功能

#### 列表

| 编号  | 按键  |    特殊情况     | 覆盖层格子类别 | 真实层格子类别 |               效果               | 实现方式 | 开发情况 |
| :---: | :---: | :-------------: | :------------: | :------------: | :------------------------------: | :------: | :------: |
|   1   | 左键  |                 |    空白未扫    |      空白      |      连片的空白、边缘的数字      |   DFS    |    1     |
|   2   |       |                 |                |      数字      |             本格数字             |          |    1     |
|   3   |       |                 |                |       雷       | 游戏失败，本格雷引爆，所有雷翻开 |          |    1     |
|   4   |       |                 |     标记格     |                |              无反应              |          |    1     |
|   5   |       |                 |     已扫格     |    空白、雷    |              无反应              |          |    1     |
|   6   |       |                 |                |      数字      |         详见列举中的解释         |          |    1     |
|   7   |       |                 |                |                |     标记数量多于雷数，无反应     |          |    1     |
|   8   | 右键  |                 |    空白未扫    |                |               标记               |          |    1     |
|   9   |       |                 |      标记      |                |             去除标记             |          |    1     |
|  10   |       |                 |     已扫格     |                |              无反应              |          |    1     |
|  11   |   -   |  剩余标记数为0  |                |                |           不能继续标记           |          |    1     |
|  12   |   -   | 未被标记雷数为0 |                |                |              无反应              |          |    1     |

#### 列举

1. 鼠标
   1. 左键
      1. 覆盖层
         1. 空白未扫
            1. 真实层
               1. 空白：翻开连片的空白、边缘的数字
               2. 数字：翻开本格
               3. 雷：游戏失败，本格雷引爆，所有雷翻开
         2. 标记：无反应
         3. 已扫
            1. 空白：无反应
            2. 雷：无反应
            3. 数字（辅助扫雷）
               1. 周围八格 标记数与雷数一致
                  1. 雷与标记位置相符合：相连的真实层为空白格子的覆盖层去除，将周围八格真实层为数字的覆盖层去除
                  2. 雷与标记位置不符合：引爆未标记的雷，触发游戏结束
               2. 周围八格 标记数比雷数少：覆盖层空白未扫格按下左键附加虚化效果，左键抬起后还原
               3. 周围八格 标记数比雷数多：无反应
   2. 右键
      1. 覆盖层
         1. 空白未扫：标记
         2. 标记：去除标记
         3. 已扫：无反应
2. 键盘
   1. a：自动扫雷
   2. f：辅助手动扫雷
3. 特判
   1. 剩余标记数为0：不能继续标记
   2. 未被标记的雷数为0：无反应
   3. 除了真实层为雷的格子以外的其他覆盖层格子全部已扫：游戏胜利

### 游戏状态判定

#### 胜利

除了真实层为雷的格子以外的其他覆盖层格子全部已扫

#### 失败

出现覆盖层已扫的雷

1. 全手动左击覆盖层为未扫、真实层为雷的格子
2. 辅助模式左击覆盖层已扫、真实层数字的格子 并且 符合

### 自动扫雷

#### 模拟人类扫雷思维算法

1. self.game_state == 'running'后，
2. 对于每个真实层为数字、覆盖层为已扫的格子进行3*3区域判断，
3. 基本规则
   1. 如果上一次基本逻辑失败，停止运行；如果组合逻辑运行成功，恢复运行。
   2. 如果区域内不是已扫的格子数量等于真实层的数字，将这些格子覆盖层标记
   3. 如果区域内标记格子数量等于真实层数字，将区域内空白未扫覆盖层的格子的覆盖层使用self.clear_blank()转化为已扫覆盖层
4. 组合逻辑（按覆盖层已扫真实层数字格）
   1. 在基本规则运用无效的时候运用组合逻辑
   2. 如果上一次组合逻辑运行失败，停止运行
   3. 如果组合逻辑运行成功，恢复基本规则运行
   4. 对于相邻两个覆盖层为已扫、真实层为数字的格子，3*3范围内覆盖层为空白未扫格子为包含关系，如果空白未扫格子中雷的数量相等，则非包含关系的格子不是雷，使用self.clear_blank()将非包含的格子转化为已扫覆盖层。
   5. 对于相邻两个覆盖层为已扫、真实层为数字的格子，3*3范围内覆盖层为空白未扫格子为交叠关系，如果空白未扫格子中雷的数量不相等并且大数字格子未被小数字格子覆盖的格子数量和大数字与小数字之差相等，则大数字非覆盖格子为雷，进行标记。
5. 按覆盖层空白未扫格

### 开发计划

* ~~标记旗帜、雷样式重做，做成图标~~
* ~~实现自定义模式，可使用按钮调节高、宽、雷数~~
* ~~分离半自动扫雷和全手动扫雷~~
* 实现全自动扫雷（二选一特殊情况留给手动）
* ~~restart图标立体化~~
* 开始游戏动画
* 覆盖层鼠标悬浮效果
* ~~写入框调节箭头悬浮效果~~
* 鼠标点击次数计数
* 本地存储用时记录
* MVC框架

## BUG实录

1. 半自动扫雷功能下，如果手动标记出现错误，程序无法自动判错，出现覆盖层已扫的雷：考虑运行顺序问题
2. 游戏结束，扫雷结束界面显示问题，出现剩余标记数计数不同步：考虑细致修改运行逻辑，保证最终界面显示所有信息

## 游戏功能记录

* 自动扫雷
  * 控制开关：a键
  * 触发条件：游戏中
  * 触发效果：详见“自动扫雷”
* 辅助扫雷
  * 控制开关：k键
  * 触发条件：左击覆盖层已扫、真实层数字
  * 触发效果：详见开发项中的交互功能
* 用时记录
  * 分类别（开启/关闭自动扫雷、开启/关闭辅助扫雷）记录扫雷用时，并存储在本地文件game_records.json文件中
  * 显示当前模式全部记录：按r键
  * 在右上角显示当前模式最佳纪录
  * 开启自动、辅助优先级高于不开启，在一局扫雷游戏进行中如果曾经开启了自动、辅助，则记录中默认使用过自动、辅助

## 注意事项

1. 记得是在主文件夹下运行程序
2. 按键功能记得在英文状态下运行

## 版本记录

### v1.0

自定义未完成
其他开发完毕

### v1.1

#### v1.1.0

在v1.0基础上添加半自动扫雷的功能
修复若干BUG

#### v1.1.1

重做标记旗帜、雷样式为图片

### v1.2

#### v1.2.0

初步实现自定义模式

#### v1.2.1

按下a键，控制半自动扫雷的开关状态

### v1.3

重塑硬编码部分，封装到*config.py*文件中，并在*assets.py*文件中预加载图片、字体资源

#### v1.3.0

1. 调整程序结构，从单一文件拓展到多文件系统，增加config.py和assets.py文件用于存储参数和预加载资源
2. 重塑程序细节，整合difficulty_buttons
3. 增加注释

#### v1.3.1

1. 自动扫雷加入组合逻辑并优化

#### v1.3.2

1. 分离全手动点击扫雷和半自动识别扫雷（点击数字判断是否已满足条件则自动点出格子）

#### v1.3.3A

1. 点击鼠标次数统计
2. 游戏单局用时记录存储及显示
3. 若干优化

## 程序结构

1. main.py              # 主程序入口
2. config.py            # 常量配置
3. assets.py            # 资源管理